<!--
pytableaux, a multi-logic proof generator.
Copyright (C) 2014-2017 Doug Owings.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

pytableaux - header for html tableau writer
-->
<style type="text/css">
    .html-writer-proof {
        cursor: pointer;
    }
    .html-writer-proof .node, .html-writer-proof .closeMark {
        text-align: center;
        margin: 3px 0;
    }
    .html-writer-proof .node-props {
        padding: 5px;
        display: inline-block;
    }
    .html-writer-proof .node .node-props.ticked {
        border-color: black;
        border-style: solid;
        border-width: 1px;
    }
    .html-writer-proof .child-wrapper {
        float: left;
    }
    .html-writer-proof .vertical-line, .html-writer-proof .horizontal-line {
        margin: 0 auto;
    }
    .html-writer-proof .horizontal-line {
        border-bottom-width: 1px;
        border-bottom-style: solid;
        border-bottom-color: black;
        margin-bottom: -1px;
    }
    .html-writer-proof .horizontal-line.collapsed {
        border-bottom-style: dotted;
    }
    .html-writer-proof .horizontal-line.branch-filtered {
        border-bottom-style: dashed;
    }
    .html-writer-proof .vertical-line {
        border-right: 1px solid black;
        height: 10px;
        width: 1px;
    }
    .html-writer-proof .subscript {
        vertical-align: sub;
        font-size: 80%;
    }
    .html-writer-proof .world {
        font-style: italic;
    }
    .html-writer-proof .node.has_open {
        color: red;
    }
    .html-writer-proof .clear, .html-writer-status-panel .clear {
        clear: both;
    }
    .html-writer-status-panel .left {
        float: left;
    }
    .html-writer-status-panel dl {
        margin: 0 0 0 3px;
    }
    .html-writer-status-panel dd {
        padding: 2px 2px 2px 4px;
        margin: 0px 0 4px 4px;
        background-color: #eee;
        float: left;
        width: 220px;
    }
    .html-writer-status-panel dt {
        float: left;
        padding: 2px 3px;
        background-color: white;
        display: inline-block;
        clear: both;
        min-width: 140px;
        text-align: right;
    }
    .html-writer-status-panel .valid {
        color: green;
    }
    .html-writer-status-panel .invalid {
        color: red;
    }
    .html-writer-status-panel a.button {
        background-color: #138ead;
        border: 1px solid #bbb;
        text-decoration: none;
        color: white;
        font-size: 0.7em;
        padding: 5px 10px;
    }
    .html-writer-status-panel a.button:hover {
        background-color: lightblue;
    }
</style>
<script>
    ;(function() {

        if (typeof($) != 'function') {
            console.error(new Error('jQuery not loaded. Not initializing interactive handlers.'))
            return
        }

        // default option sets
        const DEFAULTS = {
            FILTER : {
                $proof       : $()   ,
                $hides       : $()   ,
                $shows       : $()   ,
                className    : null  ,
                adjust       : 'after'
            }
        }

        // animation speed constants, in milliseconds.
        const ANIM = {
            FAST : 150,
            MED  : 250,
            SLOW : 500
        }

        // relationship string contants
        const REL = {
            SELF       : 'self'       ,
            ANCESTOR   : 'ancestor'   ,
            DESCENDANT : 'descendant' ,
            OUTSIDE    : 'outside'
        }

        // class names
        const CLS = {
            STRUCTURE      : 'structure'                ,
            CHILD          : 'child-wrapper'            ,
            LEAF           : 'leaf'                     ,
            PROOF          : 'html-writer-proof'        ,
            NODESEGMENT    : 'node-segment'             ,
            NODEPROPS      : 'node-props'               ,
            NODE           : 'node'                     ,
            STATUS         : 'html-writer-status-panel' ,
            ZOOMED         : 'zoomed'                   ,
            HL             : 'horizontal-line'          ,
            VL             : 'vertical-line'            ,
            COLLAPSED      : 'collapsed'                ,
            CLOSE          : 'closeMark'                ,
            STEPPREV       : 'step-prev'                ,
            STEPNEXT       : 'step-next'                ,
            STEPINPUT      : 'step-input'               ,
            STEPFILTERED   : 'step-filtered'            ,
            ZOOMFILTERED   : 'zoom-filtered'            ,
            BRANCHFILTERED : 'branch-filtered'          ,
            TICKED         : 'ticked'                   ,
            FONTPLUS       : 'font-plus'                ,
            FONTMINUS      : 'font-minus'               ,
            FONTRESET      : 'font-reset'               ,
            WIDTHPLUS      : 'width-plus'               ,
            WIDTHMINUS     : 'width-minus'              ,
            WIDTHRESET     : 'width-reset'              ,
            HASOPEN        : 'has-open'                 ,
            HASCLOSED      : 'has-closed'               ,
            BRANCHFILTER   : 'branch-filter'
        }

        // class names preceded with a '.' for selecting
        var DCLS = {}
        for (var c in CLS)
            DCLS[c] = '.' + CLS[c]

        // attributes
        const ATTR = {
            LEFT           : 'data-left'              ,
            RIGHT          : 'data-right'             ,
            STEP           : 'data-step'              ,
            TICKED         : 'data-ticked'            ,
            TICKSTEP       : 'data-ticked-step'       ,
            NUMSTEPS       : 'data-num-steps'         ,
            DEPTH          : 'data-depth'             ,
            FILTEREDWIDTH  : 'data-filtered-width'    ,
            WIDTH          : 'data-width'             ,
            CURWIDTHPCT    : 'data-current-width-pct'
        }

        // selectors
        var SEL = {
            STEPPEDCHILDS  : [
                '>' + DCLS.NODESEGMENT + '>' + DCLS.NODE,
                '>' + DCLS.NODESEGMENT + '>' + DCLS.CLOSE,
                '>' + DCLS.VL
            ].join(','),
            FILTERED       : [
                DCLS.STEPFILTERED,
                DCLS.ZOOMFILTERED,
                DCLS.BRANCHFILTERED
            ].join(',')
        }
        SEL.UNFILTERED = ':not(' + SEL.FILTERED + ')'

        /**
         * Show only the lineage of the given structure.
         *
         * @param $structure The singleton jQuery .structure element.
         * @param $proof The singleton jQuery .html-writer-proof element. If not
         *   passed, it will be retrieved.
         * @return void
         */
        function zoom($structure, $proof) {

            if (!$structure.hasClass(CLS.STRUCTURE))
                throw new Error('Invalid structure argument: ' + $structure)

            // if we are currently zoomed to this structure, there is nothing to do
            if ($structure.hasClass(CLS.ZOOMED))
                return

            if (!$proof)
                $proof = $structure.closest(DCLS.PROOF)

            // get the previously zoomed structure
            var $prev = $(DCLS.ZOOMED, $proof)

            var thisPos = getPos($structure)

            var hides = []
            var shows = []

            $(DCLS.STRUCTURE, $proof).each(function(i, s) {
                if (getRelation(getPos($(s)), thisPos) == REL.OUTSIDE)
                    hides.push(s)
                else
                    shows.push(s)
            })

            doFilter({
                $hides    : $(hides),
                $shows    : $(shows),
                $proof    : $proof,
                className : CLS.ZOOMFILTERED
            })

            // unmark the previous structure as zoomed
            $prev.removeClass(CLS.ZOOMED)

            // mark the current structure as zoomed
            $structure.addClass(CLS.ZOOMED)
        }

        /**
         * Move the proof state to the given step.
         *
         * @param $proof The singleton jQuery proof element.
         * @param n The step number.
         * @return void
         */
        function step($proof, n) {

            var numSteps = +$proof.attr(ATTR.NUMSTEPS)
            var prevStep = +$proof.attr(ATTR.STEP)

            if (n < 0)
                n = 0
            if (n > numSteps)
                n = numSteps
            if (n == prevStep)
                return

            var shows  = []
            var toHide = {}
            var showChilds  = []
            var hideChilds  = []
            var tickNodes   = []
            var untickNodes = []
            $(DCLS.STRUCTURE, $proof).each(function(i, s) {
                var $s = $(s)
                var sPos = getPos($s)
                var sStep = +$s.attr(ATTR.STEP)
                if (sStep > n) {
                    // only hide the highest structures
                    trackHighests(toHide, sPos)
                    return true
                }
                shows.push(s)
                // process nodes, markers, vertical lines
                $(SEL.STEPPEDCHILDS, $s).each(function(ni, stepped) {
                    var $stepped = $(stepped)
                    var nStep = +$stepped.attr(ATTR.STEP)
                    if (nStep > n) {
                        hideChilds.push(stepped)
                        return true
                    }
                    showChilds.push(stepped)
                    // ticking/unticking
                    if (!+$stepped.attr(ATTR.TICKED))
                        return true
                    var tStep = +$stepped.attr(ATTR.TICKSTEP)
                    var hasTicked = $(DCLS.NODEPROPS, $stepped).hasClass(CLS.TICKED)
                    if (tStep > n) {
                        if (hasTicked)
                            untickNodes.push(stepped)
                    } else {
                        if (!hasTicked)
                            tickNodes.push(stepped)
                    }
                })
            })

            // hide nodes, markers, vertical lines
            $(hideChilds).hide(ANIM.FAST)

            // untick nodes
            $(DCLS.NODEPROPS, untickNodes).removeClass(CLS.TICKED)

            // filter structures
            var hides = $.map(toHide, function(pos) { return pos.$el.get(0) })
            doFilter({
                $proof       : $proof,
                $hides       : $(hides),
                $shows       : $(shows),
                className    : CLS.STEPFILTERED,
                adjust       : n > prevStep ? 'before' : 'after'
            })

            // show nodes, markers, vertical lines
            $(showChilds).show(ANIM.MED)

            // delay the ticking of the nodes for animated effect
            setTimeout(function() { $(DCLS.NODEPROPS, tickNodes).addClass(CLS.TICKED) }, ANIM.MED)

            // set the current step attribute on the proof
            $proof.attr(ATTR.STEP, n)
            
        }

        /**
         * Filter branches of a proof according to their status.
         *
         * @param type The branch status to show, either 'open', 'closed', or 'all'.
         * @param $proof The singleton jQuery proof element.
         * @return void
         */
        function filterBranches(type, $proof) {
            if (type != 'all' && type != 'closed' && type != 'open')
                throw new Error("Invalid filter type: " + type)
            var toHide = []
            var toShow = []
            $(DCLS.STRUCTURE, $proof).each(function(i, s) {
                var $s = $(s)
                var shown
                switch (type) {
                    case 'all':
                        shown = true
                        break
                    case 'open' :
                        shown = $s.hasClass(CLS.HASOPEN)
                        break
                    case 'closed' :
                        shown = $s.hasClass(CLS.HASCLOSED)
                        break
                    default:
                        break
                }
                if (shown)
                    toShow.push(s)
                else
                    toHide.push(s)
            })
            doFilter({
                $proof       : $proof,
                $hides       : $(toHide),
                $shows       : $(toShow),
                className    : CLS.BRANCHFILTERED
            })
        }

        /**
         * Perform a filter operation on structures for a proof. This will apply
         * the filter class to $shows, and remove it from $hides. If there are
         * no more filter classes on an element, it is shown. The widths of the
         * child wrappers are then adjusted.
         *
         * Required options keys:
         *
         *     - $hides     : The jQuery structure elements to filter.
         *     - $shows     : The jQuery structure elements to unfilter.
         *     - $proof     : The singleton jQuery proof element.
         *     - className  : The filter class name to apply.
         *
         * Optional keys:
         *
         *     - adjust     : Adjust horizontal lines (boolean, 'before', or 'after').
         *                    Default is 'after'.
         *
         * @param opts The options.
         * @return void
         */
        function doFilter(opts) {

            opts = $.extend({}, DEFAULTS.FILTER, opts)

            var $hides = opts.$hides
            var $shows = opts.$shows
            var $proof = opts.$proof
            var className = opts.className

            // track the lowest structures to adjust widths
            var lowests = {}
            
            $hides.addClass(className).each(function() {
                trackLowests(lowests, getPos($(this)))
            })

            var shows = []

            $shows.removeClass(className).each(function() {
                var pos = getPos($(this))
                trackLowests(lowests, pos)
                // if there are no more filters on the element, it will be shown
                if (pos.$el.is(SEL.UNFILTERED))
                    shows.push(this)
            })

            // sort the elements to show from higher to lower
            shows.sort(function(a, b) { return $(a).attr(ATTR.DEPTH) - $(b).attr(ATTR.DEPTH) })

            // collect the dom elements of the lowest structures
            var leaves = $.map(lowests, function(pos) { return pos.$el.get(0) })

            // adjust the widths (or do this 'after' below)
            if (opts.adjust == 'before')
                adjustWidths($proof, $(leaves), true)

            // hide elements that have a filter
            $hides.hide(ANIM.FAST)

            // show elements that do not have a filter
            $(shows).show(ANIM.MED)

            if (opts.adjust && opts.adjust != 'before')
                adjustWidths($proof, $(leaves), true)
        }

        /**
         * Adjust the widths of the proof structures, after filters have been
         * applied. This takes the leaves (or lowest affected structures), and
         * traverses upward, adjusting the width of the ancestors.
         *
         * The 'leaves' will not be adjusted, since their width is fixed. True
         * leaves can only have nodes, so their width is 1.
         *
         * @param $proof The singleton proof jQuery element.
         * @param $leaves The jQuery element with the leaves, or deepest
         *   affected structures.
         * @param animate Whether to animate the width transitions. Default
         *   is to animate all horizontal lines changes, and to animate width
         *   changes if the adjusted width is known to be an increase.
         * @return void
         */
        function adjustWidths($proof, $leaves, animate) {

            if (!$leaves)
                $leaves = $(DCLS.LEAF, $proof)

            // traverse upward through the ancestors
            $leaves.parents(DCLS.STRUCTURE + SEL.UNFILTERED).each(function(pi, parent) {

                var $parent            = $(parent)

                // The horizontal line.
                var $hl                = $parent.children(DCLS.HL)

                // All the child-wrapper elements.
                var $cws               = $parent.children(DCLS.CHILD)

                // The child-wrapper elements of the structures that are 'visible'.
                var $cwsUnfiltered     = $cws.has('> ' + SEL.UNFILTERED)

                // The total number of children.
                var totalChildren      = $cws.length

                // The number of 'visible' children.
                var unfilteredChildren = $cwsUnfiltered.length

                // The list of child widths.
                var childWidths        = $cwsUnfiltered.map(function() {
                    return +(
                        $(this).attr(ATTR.FILTEREDWIDTH) ||
                        $(this).children(DCLS.STRUCTURE).attr(ATTR.WIDTH)
                    )
                }).get()

                // The total width that the parent should consume.
                var width = sum(childWidths)

                // Modify the widths of the visible children.

                $cwsUnfiltered.each(function(ci, cw) {
                    var $cw = $(cw)
                    // calculate the new percentage
                    var newWidthPct = ((childWidths[ci] * 100) / width) + '%'
                    // get the current percentage from the store attribute
                    var curWidthPct = $cw.attr(ATTR.CURWIDTHPCT) || Infinity
                    // round for comparisons
                    var cmpNew = Math.floor(parseFloat(newWidthPct) * 10000) / 10000
                    var cmpCur = Math.floor(parseFloat(curWidthPct) * 10000) / 10000
                    if (cmpNew != cmpCur) {
                        // set the current percentage attribute
                        $cw.attr(ATTR.CURWIDTHPCT, newWidthPct)
                        var css = {width: newWidthPct}
                        // only animate if the width is increasing
                        if (animate && cmpNew > cmpCur)
                            $cw.animate(css, ANIM.FAST)
                        else
                            $cw.css(css)
                    }
                })

                // Modify the horizontal line.

                var hlcss = {}

                if (unfilteredChildren < 2) {
                    // If we have 1 or 0 visible children, then make the line span 33% and center it.
                    hlcss.width = (100 / 3) + '%'
                    // jQuery does not animate 'auto' margins, so we set it immmediately.
                    $hl.css({marginLeft: 'auto'})
                } else {
                    // If there there are 2 or more visible children, calculate
                    // the line width and left margin. This is a repetition of 
                    // the server-side calculations for the initial state.
                    var first    = childWidths[0] / 2
                    var last     = childWidths[childWidths.length - 1] / 2
                    var betweens = sum(childWidths.slice(1, childWidths.length - 1))
                    hlcss.marginLeft = ((first * 100 ) / width) + '%'
                    hlcss.width = (((first + betweens + last) * 100) / width) + '%'
                }

                // If all children are visible, then restore the line style, otherwise make it dotted.
                if (totalChildren == unfilteredChildren)
                    $hl.removeClass(CLS.COLLAPSED)
                else
                    $hl.addClass(CLS.COLLAPSED)

                // Show the horizontal line if there are visible children, otherwise hide it.
                if (unfilteredChildren > 0) {
                    if (animate)
                        $hl.show(ANIM.FAST).animate(hlcss, ANIM.FAST)
                    else
                        $hl.show().css(hlcss)
                } else
                    $hl.css(hlcss).hide(animate ? ANIM.FAST : undefined)

                // If this parent has a parent, mark the filtered width attribute
                // for the next traversal.
                var $pcw = $parent.closest(DCLS.CHILD)
                if ($pcw.length) {
                    if (width == +$parent.attr(ATTR.WIDTH))
                        $pcw.removeAttr(ATTR.FILTEREDWIDTH)
                    else
                        $pcw.attr(ATTR.FILTEREDWIDTH, width || 1)
                }
            })
        }

        /**
         * Get the left/right values of the given structure, as well a reference
         * to the structure's jQuery element.
         *
         * @param $el The singleton jQuery .structure element.
         * @return A plain object with left/right/$el keys.
         */
        function getPos($el) {
            return {
                left  : +$el.attr(ATTR.LEFT),
                right : +$el.attr(ATTR.RIGHT),
                $el   : $el
            }
        }

        /**
         * Get the relation of one position object to the other (see getPos() above).
         *
         * @param of The related position object.
         * @param to The position object to compare to.
         * @return A string, either 'self', 'ancestor', 'descendant', or 'other'.
         */
        function getRelation(of, to) {
            if (of.left == to.left)
                return REL.SELF
            if (of.left < to.left && of.right > to.right)
                return REL.ANCESTOR
            if (of.left > to.left && of.right < to.right)
                return REL.DESCENDANT
            return REL.OUTSIDE
        }

        /**
         * Track only the highest disjoint positions. This checks pos against the
         * values already in trackObj. If pos is a descendant of a position already
         * in trackObj, then it is not added. If it is an ancestor, then it is added
         * to trackObj, and the descendant positions in trackObj are removed.
         *
         * @param trackObj The object store to check and modify.
         * @param pos The position object to potentially add.
         * @return void
         */
        function trackHighests(trackObj, pos) {
            consolidateRelated(REL.DESCENDANT, REL.ANCESTOR, trackObj, pos)
        }

        /**
         * Track only the lowest disjoint positions. This checks pos against the
         * values already in trackObj. If pos is an ancestor of a position already
         * in trackObj, then it is not added. If it is a descendant, then it is added
         * to trackObj, and the ancestor positions in trackObj are removed.
         *
         * @param trackObj The object store to check and modify.
         * @param pos The position object to potentially add.
         * @return void
         */
        function trackLowests(trackObj, pos) {
            consolidateRelated(REL.ANCESTOR, REL.DESCENDANT, trackObj, pos)
        }

        /**
         * Track only the highest or lowest positions of a lineage. This is the
         * generic function for trackHighests() and tackLowests().
         *
         * @param dropIf The relation to drop, either descendant or ancestor.
         * @param replaceIf The relation to replace, either ancestor or descendant.
         * @param trackObj The object store to check and modify.
         * @param The position object to potentially add.
         * @return void
         */
        function consolidateRelated(dropIf, replaceIf, trackObj, pos) {
            var replaces = []
            for (var hleft in trackObj) {
                var hpos = trackObj[hleft]
                var relation = getRelation(pos, hpos)
                if (relation == dropIf)
                    return
                if (relation == replaceIf)
                    replaces.push(hleft)
            }
            for (var i = 0; i < replaces.length; i++)
                delete(trackObj[replaces[i]])
            trackObj[pos.left] = pos
        }

        /**
         * Sum all elements in an array. Return 0 if empty.
         *
         * @param arr The array.
         * @return The sum, or 0 if empty.
         */
        function sum(arr) {
            return arr.reduce(function(a, b) { return a + b }, 0)
        }

        /**
         * Get the status panel element(s) from the proof element(s).
         *
         * @param $proof The jQuery proof element(s).
         * @return The jQuery status panel element(s).
         */
        function getStatusFromProof($proof) {
            return $proof.prevAll(DCLS.STATUS)
        }

        /**
         * Get the proof element(s) from the status panel element(s).
         *
         * @param $status The jQuery status panel element(s).
         * @return The jQuery proof element(s).
         */
        function getProofFromStatus($status) {
            return $status.nextAll(DCLS.PROOF)
        }

        $(document).ready(function() {

            var modkey = {
                shift : false,
                ctrl  : false,
                alt   : false
            }

            // monitor modifier keys
            $(document).on('keyup keydown', function(e) {
                modkey.shift = e.shiftKey
                modkey.ctrl  = e.metaKey || e.ctrlKey
                modkey.alt   = e.altKey
            })

            $(DCLS.PROOF).on('keypress', function(e) {
                var $target = $(e.target)
            })

            // load a click event handler for each proof in the document.
            $(DCLS.PROOF).on('click', function(e) {
                var $proof = $(this)
                var $target = $(e.target)
                var $status = getStatusFromProof($proof)
                var behavior = 'inspect'
                if (modkey.ctrl || modkey.alt)
                    behavior = 'zoom'
                switch (behavior) {
                    case 'zoom':
                        var $structure = $target.closest(DCLS.STRUCTURE)
                        if ($structure.length)
                            zoom($structure, $proof)
                        break
                    case 'inspect':
                        break
                    default :
                        break
                }
            })

            // load a change event for the status panel
            $(DCLS.STATUS).on('change', function(e) {
                var $status = $(this)
                var $proof = getProofFromStatus($status)
                var $target = $(e.target)
                if ($target.hasClass(CLS.STEPINPUT)) {
                    var n = +$target.val()
                    var maxSteps = +$proof.attr(ATTR.NUMSTEPS)
                    if (isNaN(n) || n < 0 || n > maxSteps) {
                        $target.val($proof.attr(ATTR.STEP))
                        return
                    }
                    step($proof, n)
                } else if ($target.hasClass(CLS.BRANCHFILTER)) {
                    filterBranches($target.val(), $proof)
                }
            })

            // load a click event for the status panel
            $(DCLS.STATUS).on('click', function(e) {
                var $status = $(this)
                var $proof = getProofFromStatus($status)
                var $target = $(e.target)
                if ($target.hasClass(CLS.STEPNEXT)) {
                    var maxSteps = +$proof.attr(ATTR.NUMSTEPS)
                    var n = modkey.shift ? maxSteps : +$proof.attr(ATTR.STEP) + 1
                    if (n > maxSteps)
                        return
                    $(DCLS.STEPINPUT, $status).val(n)
                    step($proof, n)
                } else if ($target.hasClass(CLS.STEPPREV)) {
                    var n = modkey.shift ? 0 : +$proof.attr(ATTR.STEP) - 1
                    if (n < 0)
                        return
                    $(DCLS.STEPINPUT, $status).val(n)
                    step($proof, n)
                } else if ($target.hasClass(CLS.FONTPLUS)) {
                    $proof.css({fontSize: parseInt($proof.css('font-size')) + 1})
                } else if ($target.hasClass(CLS.FONTMINUS)) {
                    $proof.css({fontSize: parseInt($proof.css('font-size')) - 1})
                } else if ($target.hasClass(CLS.FONTRESET)) {
                    $proof.css({fontSize: 'inherit'})
                } else if ($target.hasClass(CLS.WIDTHPLUS)) {
                    var p = +$proof.attr(ATTR.CURWIDTHPCT)
                    if (modkey.shift)
                        p += 100
                    else if (modkey.ctrl || modkey.alt)
                        p += 25
                    else
                        p += 10
                    $proof.attr(ATTR.CURWIDTHPCT, p)
                    $proof.css({width: p + '%'})
                } else if ($target.hasClass(CLS.WIDTHMINUS)) {
                    var p = +$proof.attr(ATTR.CURWIDTHPCT)
                    if (modkey.shift)
                        p -= 100
                    else if (modkey.ctrl || modkey.alt)
                        p -= 25
                    else
                        p -= 10
                    if (p < 0)
                        p = 0
                    $proof.attr(ATTR.CURWIDTHPCT, p)
                    $proof.css({width: p + '%'})
                } else if ($target.hasClass(CLS.WIDTHRESET)) {
                    var p = 100
                    $proof.attr(ATTR.CURWIDTHPCT, p)
                    $proof.css({width: p + '%'})
                }
            })
        })

    })();
</script>