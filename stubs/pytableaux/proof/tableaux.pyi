from typing import (Any, ClassVar, Iterable, Iterator, Literal, Mapping, Sequence,
                    SupportsIndex, overload)

from pytableaux.lang import Sentence, Argument
from pytableaux.models import BaseModel
from pytableaux.proof import (LogicType, RuleClassFlag, RuleHelper, RuleMeta,
                              RuleState, StepEntry, TabFlag, TableauxSystem,
                              TabStatKey, TabTimers, Branch, Node, Target)
from pytableaux.tools.events import EventEmitter
from pytableaux.tools.hybrids import qsetf
from pytableaux.tools.mappings import dmapns
from pytableaux.tools.sequences import SequenceApi, seqm
from pytableaux.tools.sets import setf
from pytableaux.tools.timing import StopWatch
from pytableaux.typing import _T, _RuleT, _TypeInstDict, _LogicLookupKey


class Rule(EventEmitter, metaclass=RuleMeta):
    _defaults: ClassVar[Mapping[str, Any]]
    _optkeys: ClassVar[setf[str]]
    FLAGS: ClassVar[RuleClassFlag]
    legend: ClassVar[tuple]
    Helpers: ClassVar[Mapping[type[RuleHelper], Any]]
    Timers: ClassVar[qsetf[str]]
    name: ClassVar[str]
    branching: ClassVar[int]
    tableau: Tableau
    opts: Mapping[str, bool]
    helpers: _TypeInstDict[RuleHelper]
    timers: Mapping[str, StopWatch]
    history: Sequence[Target]
    state: RuleState
    def __getitem__(self, key: type[_T]) -> _T: ...
    def __init__(self, tableau: Tableau, **opts) -> None: ...
    def example_nodes(self) -> Iterable[Mapping]: ...
    def sentence(self, node: Node) -> Sentence|None: ...
    def group_score(self, target: Target) -> float: ...
    def score_candidate(self, target: Target) -> float: ...
    def target(self, branch: Branch) -> Target|None: ...
    def apply(self, target: Target) -> None: ...
    def branch(self, parent: Branch = ...) -> Branch: ...
    def stats(self) -> dict[str, Any]: ...
    @classmethod
    def test(cls, *, noassert: bool = ...): ...

class TabRuleGroups(SequenceApi[Rule]):
    groups: RuleGroups
    def __init__(self, tab: Tableau) -> None: ...
    def append(self, rule: type[Rule]): ...
    def extend(self, rules: Iterable[type[Rule]], name: str|None = ...): ...
    def clear(self) -> None: ...
    @overload
    def get(self, ref: type[_RuleT], default=...) -> _RuleT: ...
    @overload
    def get(self, ref: str, default=...) -> Rule: ...
    def names(self) -> list[str]: ...
    @overload
    def __getitem__(self, i: SupportsIndex) -> Rule: ...
    @overload
    def __getitem__(self, s: slice) -> Sequence[Rule]: ...

class RuleGroup(SequenceApi[Rule]):
    def __init__(self, name: str|None, root: TabRuleGroups) -> None: ...
    @property
    def name(self) -> str|None: ...
    def append(self, value: type[Rule]): ...
    def extend(self, values: Iterable[type[Rule]]): ...
    def clear(self) -> None: ...
    @overload
    def get(self, ref: type[_RuleT], default=...) -> _RuleT: ...
    @overload
    def get(self, ref: str, default=...) -> Rule: ...
    def names(self) -> list[str]: ...
    @overload
    def __getitem__(self, i: SupportsIndex) -> Rule: ...
    @overload
    def __getitem__(self, s: slice) -> Sequence[Rule]: ...

class RuleGroups(SequenceApi[RuleGroup]):
    def __init__(self, root: TabRuleGroups) -> None: ...
    def create(self, name: str = ...) -> RuleGroup: ...
    def append(self, Rules: Iterable[type[Rule]], name: str|None = ...) -> None: ...
    def extend(self, groups: Iterable[Iterable[type[Rule]]]) -> None: ...
    def clear(self) -> None: ...
    def get(self, name: str, default=...) -> RuleGroup: ...
    def names(self) -> seqm[str]: ...

class Tableau(Sequence[Branch], EventEmitter):
    argument: Argument|None
    System: TableauxSystem|None
    rules: TabRuleGroups
    opts: Mapping[str, bool|int, None]
    completed: bool
    finished: bool
    premature: bool
    valid: bool|None
    invalid: bool|None
    current_step: int
    open: Sequence[Branch]
    history: Sequence[StepEntry]
    tree: TreeStruct
    stats: dict[str, Any]
    models: setf[BaseModel]
    timers: TabTimers
    def __init__(self, logic: _LogicLookupKey = ..., argument: Argument = ..., **opts) -> None: ...
    @property
    def id(self) -> int: ...
    @property
    def flag(self) -> TabFlag: ...
    @property
    def argument(self) -> Argument|None: ...
    @property
    def logic(self) -> LogicType|None: ...
    @property
    def System(self) -> TableauxSystem|None: ...
    @argument.setter
    def argument(self, argument: Argument): ...
    @logic.setter
    def logic(self, logic: _LogicLookupKey): ...
    @property
    def finished(self) -> bool: ...
    @property
    def completed(self) -> bool: ...
    @property
    def premature(self) -> bool: ...
    @property
    def valid(self) -> bool: ...
    @property
    def invalid(self) -> bool: ...
    @property
    def current_step(self) -> int: ...
    def build(self) -> Tableau: ...
    def next(self) -> StepEntry|None: ...
    def step(self) ->StepEntry|None|Literal[False]: ...
    def branch(self, parent: Branch = ...) -> Branch: ...
    def add(self, branch: Branch) -> Tableau: ...
    def finish(self) -> Tableau: ...
    def branching_complexity(self, node: Node) -> int: ...
    def stat(self, branch: Branch, *keys: Node|TabStatKey) -> Any: ...
    @overload
    def __getitem__(self, s: slice) -> list[Branch]: ...
    @overload
    def __getitem__(self, i: SupportsIndex) -> Branch: ...

class TreeStruct(dmapns):
    root: bool
    nodes: list[Node]
    ticksteps: list[int|None]
    children: list[TreeStruct]
    leaf: bool
    closed: bool
    open: bool
    left: int
    right: int
    descendant_node_count: int
    structure_node_count: int
    depth: int
    has_open: bool
    has_closed: bool
    closed_step: int|None
    step: int
    width: int
    balanced_line_width: float
    balanced_line_margin: float
    branch_id: int|None
    model_id: int|None
    is_only_branch: bool
    branch_step: int
    id: int
    def __init__(self) -> None: ...
