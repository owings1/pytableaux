from collections.abc import Set
from typing import Any, Optional

from pytableaux.lang import Constant, Operator, Sentence
from pytableaux.proof import (Access, Branch, ClosingRule, Node, Rule,
                              RuleHelper, Target)
from pytableaux.typing import (_KT, _T, _VT, _FiltersDict, _NodePredFunc,
                               _NodeTargetsFn, _NodeTargetsGen)


class AdzHelper(RuleHelper):
    rule: Rule
    closure_rules: tuple[ClosingRule, ...]
    def closure_score(self, target: Target) -> float: ...
    def _apply(self, target: Target) -> None:...

class BranchCache(dict[Branch, _T], RuleHelper): ...
class BranchDictCache(BranchCache[dict[_KT, _VT]]):...
class QuitFlag(BranchCache[bool]): ...

class BranchValueHook(BranchCache[_VT]):
    hook_method_name: str
    def hook(self, node: Node, branch: Branch) -> Optional[_VT]: ...

class BranchTarget(BranchValueHook[Target]):...
class AplSentCount(BranchCache[dict[Sentence, int]]): ...

class NodeCount(BranchCache[dict[Node, int]]):
    def min(self, branch: Branch) -> int: ...
    def isleast(self, node: Node, branch: Branch) -> bool: ...

class NodesWorlds(BranchCache[set[tuple[Node, int]]]):...
class UnserialWorlds(BranchCache[set[int]]):...

class WorldIndex(BranchDictCache[int, set[int]]):
    nodes: WorldIndex.Nodes
    class Nodes(BranchCache[dict[Access, Node]]):
        def add(self, node: Node, branch: Branch): ...
    def has(self, branch: Branch, access: Access) -> bool: ...
    def intransitives(self, branch: Branch, w1: int, w2: int) -> set[int]: ...

class FilterNodeCache(BranchCache[set[Node]]):
    ignore_ticked: bool
    _garbage: set[tuple[Branch, Node]]
    def __call__(self, node: Node, branch: Branch) -> bool: ...
    def release(self, node: Node, branch: Branch) -> None: ...
    def gc(self) -> None: ...
    @classmethod
    def node_targets(cls, node_targets_fn: _NodeTargetsFn) -> _NodeTargetsGen: ...

class PredNodes(FilterNodeCache): ...

class FilterHelper(FilterNodeCache):
    filters: _FiltersDict
    def filter(self, node: Node, branch: Branch) -> bool: ...
    def pred(self, node: Node) -> bool:...
    def example_node(self) -> dict[str, Any]: ...
    @staticmethod
    def _build_config(rule: Rule) -> tuple[_FiltersDict, _NodePredFunc]: ...

class NodeConsts(BranchDictCache[Node, set[Constant]]):
    consts: NodeConsts.Consts
    class Consts(BranchCache[set[Constant]]): ...
    def filter(self, node: Node, branch: Branch) -> bool: ...

class WorldConsts(BranchDictCache[int, set[Constant]]): ...

class MaxConsts(dict[Branch, int], RuleHelper):
    wconsts: WorldConsts
    def is_reached(self, branch: Branch, world: int = ...) -> bool: ...
    def is_exceeded(self, branch: Branch, world: int = ...) -> bool: ...
    def quit_flag(self, branch: Branch) -> dict: ...

class MaxWorlds(dict[Branch, int], RuleHelper):
    modals: MaxWorlds.Modals
    class Modals(dict[Sentence, int]):
        def filter(self, operator: Operator) -> bool: ...
        def __init__(self, operators: Set[Operator]) -> None:...
    def is_reached(self, branch: Branch) -> bool: ...
    def is_exceeded(self, branch: Branch) -> bool: ...
    def quit_flag(self, branch: Branch) -> dict[str, Any]: ...
