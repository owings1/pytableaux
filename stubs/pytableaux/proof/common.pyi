from typing import (Any, Collection, Iterable, Iterator, Literal, Mapping, Set,
                    SupportsIndex, overload)

from pytableaux.lang import Constant, Sentence
from pytableaux.models import BaseModel
from pytableaux.proof.tableaux import Rule
from pytableaux.tools import abcs
from pytableaux.tools.events import EventEmitter
from pytableaux.tools.hybrids import qset
from pytableaux.tools.mappings import MapCover, dmapattr
from pytableaux.tools.sequences import SequenceApi
from pytableaux.tools.sets import SetView
from pytableaux.typing import _Self


class Node(MapCover, abcs.Copyable):
    def __init__(self, arg: Mapping = ...): ...
    @property
    def id(self) -> int: ...
    @property
    def is_closure(self) -> bool: ...
    @property
    def is_modal(self) -> bool: ...
    @property
    def is_access(self) -> bool: ...
    @property
    def worlds(self, *, names=...) -> frozenset[int]: ...
    def has(self, *names: str) -> bool: ...
    def any(self, *names: str) -> bool: ...
    def meets(self, props: Mapping) -> bool: ...
    @overload
    def get(self, key: Literal['sentence']) -> Sentence|None: ...
    @overload
    def get(self, key: Literal['designated']) -> bool|None:...
    @overload
    def get(self, key: str) -> Any:...
    @overload
    def __getitem__(self, key: Literal['sentence']) -> Sentence: ...
    @overload
    def __getitem__(self, key: Literal['designated']) -> bool:...
    @overload
    def __getitem__(self, key: str) -> Any:...

class Branch(SequenceApi[Node], EventEmitter):
    def __init__(self, parent: Branch = ...) -> None: ...
    def copy(self:_Self, *, parent: Branch = ..., listeners: bool = ...) -> _Self: ...
    @property
    def id(self) -> int: ...
    @property
    def parent(self) -> Branch|None: ...
    @property
    def origin(self) -> Branch: ...
    @property
    def closed(self) -> bool: ...
    @property
    def leaf(self) -> Node|None: ...
    @property
    def model(self) -> BaseModel|None: ...
    @model.setter
    def model(self, model: BaseModel): ...
    @property
    def worlds(self) -> SetView[int]: ...
    @property
    def constants(self) -> SetView[Constant]: ...
    def has(self, props: Mapping) -> bool: ...
    def any(self, mappings: Iterable[Mapping]) -> bool: ...
    def all(self, mappings: Iterable[Mapping]) -> bool: ...
    def find(self, props: Mapping) -> Node|None: ...
    def search(self, props: Mapping, limit: int = ...) -> Iterator[Node]: ...
    def append(self:_Self, node: Mapping) -> _Self: ...
    def add(self:_Self, node: Mapping) -> _Self: ...
    def extend(self:_Self, nodes: Iterable[Mapping]) -> _Self: ...
    def tick(self, node: Node) -> None: ...
    def close(self:_Self) -> _Self: ...
    def is_ticked(self, node: Node) -> bool: ...
    def new_constant(self) -> Constant: ...
    def new_world(self) -> int: ...
    @overload
    def __getitem__(self, index: SupportsIndex) -> Node:...
    @overload
    def __getitem__(self, slice_: slice) -> qset[Node]:...
    class Index(dict[str, dict[Any, set[Node]]], abcs.Copyable):
        def __init__(self) -> None: ...
        def add(self, node: Node): ...
        def select(self, props: Mapping, default: Collection[Node]) -> Collection[Node]: ...

class Target(dmapattr[str, Any]):
    branch: Branch
    constant: Constant
    designated: bool
    flag: str
    node: Node
    nodes: Set[Node]
    rule: Rule
    sentence: Sentence
    world: int
    world1: int
    world2: int
    def __init__(self, it: Iterable = ..., **kw) -> None: ...# type:ignore
    @property
    def type(self) -> str: ...# type:ignore
