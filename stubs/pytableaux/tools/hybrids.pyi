from collections.abc import MutableSequence, MutableSet, Sequence, Set
from typing import (Collection, Iterable, Iterator, Self, SupportsIndex,
                    TypeVar, overload)

from pytableaux.tools import abcs

_T = TypeVar('_T')
_T_co = TypeVar('_T_co', covariant=True)
__QsetT = TypeVar('__QsetT', bound = SequenceSet)
_self = TypeVar('_self')

EMPTY_QSET: qsetf

class SequenceSet(Sequence[_T_co], Set[_T_co], metaclass = abcs.AbcMeta):
    def __mul__(self, other:SupportsIndex) -> Self: ...
    def __rmul__(self, other:SupportsIndex) -> Self: ...
    @classmethod
    def _from_iterable(cls:type[__QsetT], it:Iterable) -> __QsetT:...

class qsetf(SequenceSet[_T_co], abcs.Copyable):
    def __init__(self, values: Iterable = ...) -> None: ...
    def copy(self) -> Self: ...
    @overload
    def __getitem__(self, index: slice) -> Self: ...
    @overload
    def __getitem__(self, index: SupportsIndex) -> _T_co: ...
    def __iter__(self) -> Iterator[_T_co]: ...
    def __reversed__(self) -> Iterator[_T_co]: ...

class QsetView(SequenceSet[_T_co], abcs.Copyable):
    def copy(self) -> Self: ...

class MutableSequenceSet(SequenceSet[_T_co], MutableSequence[_T_co], MutableSet[_T_co]):
    def add(self, value:_T_co) -> None: ...
    def discard(self, value:_T_co) -> None: ...
    def reverse(self) -> None: ...
    def update(self, values:Iterable[_T_co]) -> None: ...

class qset(MutableSequenceSet[_T_co], abcs.Copyable):
    def __init__(self, values: Iterable = ...) -> None: ...
    def copy(self) -> Self: ...
    @overload
    def __getitem__(self, index: slice) -> Self: ...
    @overload
    def __getitem__(self, index: SupportsIndex) -> _T_co: ...
    def insert(self, index: SupportsIndex, value:_T_co) -> None: ...
    def __delitem__(self, key: SupportsIndex|slice,) -> None: ...
    @overload
    def __setitem__(self, key: SupportsIndex, value: _T_co) -> None: ...
    @overload
    def __setitem__(self, key: slice, value: Collection[_T_co]) -> None: ...
