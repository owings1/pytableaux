from collections.abc import Set
from types import MappingProxyType as MapProxy
from typing import (Any, Generic, Iterable, Mapping, MutableMapping,
                    Reversible, overload)

from pytableaux.tools import abcs
from pytableaux.typing import _KT, _T, _VT, _MapT, _Self, _SetT


class MappingApi(Mapping[_KT, _VT], Reversible[_KT], abcs.Copyable):
    def __or__(self: _MapT, other: Mapping) -> _MapT: ...
    @overload
    def __ror__(self: _MapT, other: Mapping) -> _MapT: ...
    @overload
    def __ror__(self, other: _SetT) -> _SetT: ...
    def __mod__(self: _MapT, other: Mapping) -> _MapT: ...
    def __rmod__(self:_MapT, other: Mapping) -> _MapT: ...
    def __and__(self: _MapT, other: Set) -> _MapT: ...
    def __rand__(self, other: _SetT) -> _SetT: ...
    def __sub__(self: _MapT, other: Set) -> _MapT: ...
    def __rsub__(self, other: _SetT) -> _SetT: ...
    def __rxor__(self, other: _SetT) -> _SetT: ...
    def copy(self: _T) -> _T:...
    def _asdict(self) -> dict[_KT, _VT]:...

    @classmethod
    def _from_mapping(cls: type[_MapT], mapping: Mapping) -> _MapT:...
    @classmethod
    def _from_iterable(cls: type[_MapT], it: Iterable[tuple[Any, Any]], /) -> _MapT:...
    @classmethod
    def _oper_res_type(cls, othrtype:type[Iterable], /) -> type[Mapping]:...
    @classmethod
    def _roper_res_type(cls, othrtype:type[Iterable], /) -> type[Mapping]:...

class MapCover(MappingApi[_KT, _VT]):
    def __init__(self, mapping: Mapping, /) -> None:...

class MutableMappingApi(MappingApi[_KT, _VT], MutableMapping[_KT, _VT]):
    @classmethod
    def _setitem_update(self, it: Iterable = ..., /, **kw):...
    def __ior__(self:_Self, other:Iterable) -> _MapT:...
    def __imod__(self:_Self, other:Iterable) -> _MapT:...
    def __iand__(self:_Self, other:Set) -> _MapT: ...
    def __isub__(self:_Self, other:Iterable) -> _MapT: ...

class KeySetAttr:
    def update(self, it: Iterable = ..., /, **kw) -> None: ...
    @classmethod
    def _keyattr_ok(cls, name: str) -> bool:...

class dictattr(KeySetAttr, dict[_KT, _VT]):...

class dictns(dictattr[_KT, _VT]):...

class ItemMapEnum(abcs.Ebc):
    @overload
    def __init__(self, mapping: Mapping) -> None: ...
    @overload
    def __init__(self, *items: tuple[Any, Any]): ...
    def __or__(self: _MapT, other: Mapping) -> _MapT: ...
    def __ror__(self, other: _SetT) -> _SetT: ...
    def __mod__(self: _MapT, other: Mapping) -> _MapT: ...
    def __rmod__(self: _MapT, other: Mapping) -> _MapT: ...
    def __and__(self: _MapT, other: Set) -> _MapT: ...
    def __rand__(self, other: _SetT) -> _SetT: ...
    def __sub__(self: _MapT, other: _SetT) -> _MapT: ...
    def __rsub__(self, other: _SetT) -> _SetT: ...
    def __rxor__(self, other: _SetT) -> _SetT: ...
    @classmethod
    def _oper_res_type(cls, othrtype: type[Iterable], /) -> type[dict]:...
    @classmethod
    def _roper_res_type(cls, othrtype: type[Iterable], /) -> type[dict]:...

class DequeCache(Generic[_VT]):
    @property
    def maxlen(self) -> int:...
    def __init__(self, maxlen:int|None = ...) -> None: ...

