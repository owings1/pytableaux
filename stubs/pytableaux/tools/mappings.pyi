from collections.abc import Set
from types import MappingProxyType as MapProxy
from typing import Any, Generic, Iterable, Mapping, overload

from pytableaux.tools import abcs
from pytableaux.typing import _KT, _T, _VT, _MapT, _Self, _SetT

class MapCover(Mapping[_KT, _VT], abcs.Copyable):
    def __init__(self, mapping: Mapping, /) -> None:...

class KeySetAttr:
    def update(self, it: Iterable = ..., /, **kw) -> None: ...
    @classmethod
    def _keyattr_ok(cls, name: str) -> bool:...

class dictattr(KeySetAttr, dict[_KT, _VT]):...

class dictns(dictattr[_KT, _VT]):...

class ItemMapEnum(abcs.Ebc):
    @overload
    def __init__(self, mapping: Mapping) -> None: ...
    @overload
    def __init__(self, *items: tuple[Any, Any]): ...
    def __or__(self: _MapT, other: Mapping) -> _MapT: ...
    def __ror__(self, other: _SetT) -> _SetT: ...
    def __mod__(self: _MapT, other: Mapping) -> _MapT: ...
    def __rmod__(self: _MapT, other: Mapping) -> _MapT: ...
    def __and__(self: _MapT, other: Set) -> _MapT: ...
    def __rand__(self, other: _SetT) -> _SetT: ...
    def __sub__(self: _MapT, other: _SetT) -> _MapT: ...
    def __rsub__(self, other: _SetT) -> _SetT: ...
    def __rxor__(self, other: _SetT) -> _SetT: ...
    @classmethod
    def _oper_res_type(cls, othrtype: type[Iterable], /) -> type[dict]:...
    @classmethod
    def _roper_res_type(cls, othrtype: type[Iterable], /) -> type[dict]:...

class DequeCache(Generic[_VT]):
    @property
    def maxlen(self) -> int:...
    def __init__(self, maxlen:int|None = ...) -> None: ...

