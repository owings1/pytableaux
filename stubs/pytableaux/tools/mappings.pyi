from collections import defaultdict
from collections.abc import Set
from types import MappingProxyType as MapProxy
from typing import (Any, Callable, Generic, Iterable, Iterator, Mapping,
                    MutableMapping, Reversible, TypeVar, overload)

from pytableaux.tools import abcs
from pytableaux.typing import _T, _KT, _VT, _MapT, _SetT, _Self




EMPTY_MAP: MapProxy

class MappingApi(Mapping[_KT, _VT], Reversible[_KT], abcs.Copyable):
    def __or__(self: _MapT, other: Mapping) -> _MapT: ...
    @overload
    def __ror__(self: _MapT, other: Mapping) -> _MapT: ...
    @overload
    def __ror__(self, other: _SetT) -> _SetT: ...
    def __mod__(self: _MapT, other: Mapping) -> _MapT: ...
    def __rmod__(self:_MapT, other: Mapping) -> _MapT: ...
    def __and__(self: _MapT, other: Set) -> _MapT: ...
    def __rand__(self, other: _SetT) -> _SetT: ...
    def __sub__(self: _MapT, other: Set) -> _MapT: ...
    def __rsub__(self, other: _SetT) -> _SetT: ...
    def __rxor__(self, other: _SetT) -> _SetT: ...
    def copy(self: _T) -> _T:...
    def _asdict(self) -> dict[_KT, _VT]:...

    @classmethod
    def _from_mapping(cls: type[_MapT], mapping: Mapping) -> _MapT:...
    @classmethod
    def _from_iterable(cls: type[_MapT], it: Iterable[tuple[Any, Any]], /) -> _MapT:...
    @classmethod
    def _oper_res_type(cls, othrtype:type[Iterable], /) -> type[Mapping]:...
    @classmethod
    def _roper_res_type(cls, othrtype:type[Iterable], /) -> type[Mapping]:...

class MapCover(MappingApi[_KT, _VT]):
    def __init__(self, mapping: Mapping, /) -> None:...

class MutableMappingApi(MappingApi[_KT, _VT], MutableMapping[_KT, _VT]):
    @classmethod
    def _setitem_update(self, it: Iterable = ..., /, **kw):...
    def __ior__(self:_Self, other:Iterable) -> _MapT:...
    def __imod__(self:_Self, other:Iterable) -> _MapT:...
    def __iand__(self:_Self, other:Set) -> _MapT: ...
    def __isub__(self:_Self, other:Iterable) -> _MapT: ...

class dmap(MutableMappingApi[_KT, _VT], dict[_KT, _VT]):...

class defaultdmap(MutableMappingApi[_KT, _VT], defaultdict[_KT, _VT]):...

class KeySetAttr:
    def update(self, it: Iterable = None, /, **kw) -> None: ...
    @classmethod
    def _keyattr_ok(cls, name: str) -> bool:...

class dmapattr(KeySetAttr, dmap[_KT, _VT]):...

class dmapns(dmapattr[_KT, _VT]):...

class ItemMapEnum(abcs.Ebc):
    @overload
    def __init__(self, mapping: Mapping) -> None: ...
    @overload
    def __init__(self, *items: tuple[Any, Any]): ...
    def __or__(self: _MapT, other: Mapping) -> _MapT: ...
    def __ror__(self, other: _SetT) -> _SetT: ...
    def __mod__(self: _MapT, other: Mapping) -> _MapT: ...
    def __rmod__(self: _MapT, other: Mapping) -> _MapT: ...
    def __and__(self: _MapT, other: Set) -> _MapT: ...
    def __rand__(self, other: _SetT) -> _SetT: ...
    def __sub__(self: _MapT, other: _SetT) -> _MapT: ...
    def __rsub__(self, other: _SetT) -> _SetT: ...
    def __rxor__(self, other: _SetT) -> _SetT: ...
    @classmethod
    def _oper_res_type(cls, othrtype: type[Iterable], /) -> type[dict]:...
    @classmethod
    def _roper_res_type(cls, othrtype: type[Iterable], /) -> type[dict]:...

class DequeCache(Generic[_VT]):
    @property
    def maxlen(self) -> int:...
    def __init__(self, maxlen:int|None = ...) -> None: ...

class ItemsIterator(Iterator[tuple[_KT, _VT]]):
    def __init__(self,
        obj: Mapping[_KT, _VT]|Iterable[tuple[_KT, _VT]]|Iterable[_KT],
        /, *, 
        vget: Callable[[_KT], _VT]|None = ...,
        kpred: Callable[[_KT], bool] = ...,
        vpred: Callable[[_VT], bool] = ...,
        koper: Callable[[bool], bool] = ...,
        voper: Callable[[bool], bool] = ...,
    ) -> None: ...

