from collections.abc import MutableSet, Set
from typing import Iterable, TypeVar
_T = TypeVar('_T')
_T_co = TypeVar('_T_co', covariant=True)
_SetT = TypeVar('_SetT', bound = SetApi)

EMPTY_SET: setf

class SetApi(Set[_T_co]):
    def __or__(self:_SetT, other: Iterable) -> _SetT: ...
    def __and__(self:_SetT, other: Iterable) -> _SetT: ...
    def __sub__(self:_SetT, other: Iterable) -> _SetT: ...
    def __xor__(self:_SetT, other: Iterable) -> _SetT: ...
    def issubset(self, other: Iterable) -> bool: ...
    def issuperset(self, other: Iterable) -> bool: ...
    def union(self:_SetT, *others: Iterable) -> _SetT: ...
    def intersection(self:_SetT, *others: Iterable) -> _SetT: ...
    def difference(self:_SetT, *others: Iterable) -> _SetT: ...
    def symmetric_difference(self:_SetT, other: Iterable) -> _SetT: ...
    def copy(self:_T) -> _T: ...
    @classmethod
    def _from_iterable(cls: type[_SetT], it: Iterable) -> _SetT:...

class MutableSetApi(MutableSet[_T_co], SetApi[_T_co]):
    def update(self, *others: Iterable) -> None: ...
    def intersection_update(self, *others: Iterable) -> None: ...
    def difference_update(self, *others: Iterable) -> None: ...
    def symmetric_difference_update(self, other: Iterable) -> None: ...

class setf(SetApi[_T_co], frozenset[_T_co]): ...
class setm(MutableSetApi[_T_co], set[_T_co]): ...
class SetView(SetApi[_T_co]):...