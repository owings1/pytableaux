from _typeshed import Incomplete
from pytableaux.logics import LogicType
from pytableaux.proof import Branch, Node, Rule, Target
from typing import Any, Collection, overload

def is_concrete_build_trunk(obj: Any): ...
def is_concrete_rule(obj: Any) -> bool: ...
@overload
def is_enum_member(modname: str, objpath: list[str])-> bool:...
@overload
def is_enum_member(fullname: str)-> bool:...
def is_transparent_rule(obj: Any) -> bool: ...
def rule_sortkey_legend(rule: type[Rule]):...
def rules_grouped_legend_order(rules: Collection[type[Rule]], /) -> dict[str, list[type[Rule]]]:...
def rules_legend_subgroups(groups: dict[str, list[type[Rule]]]) -> dict[str, dict[Any, list[type[Rule]]]]:...
def rules_sorted_member_order(logic: LogicType, rules: Collection[type[Rule]], /) -> list[type[Rule]]:...
def rules_sorted(logic: LogicType, rules: Collection[type[Rule]] = ..., /) -> dict[str, Any]:...

class EllipsisExampleHelper:
    mynode: Incomplete
    closenodes: list[Node]
    applied: set[Branch]
    isclosure: bool
    istrunk: bool
    rule: Incomplete
    def __init__(self, rule: Rule) -> None: ...
    def before_trunk_build(self, *_) -> None: ...
    def after_trunk_build(self, *_) -> None: ...
    def after_branch_add(self, branch: Branch): ...
    def after_node_add(self, node: Node, branch: Branch): ...
    def before_apply(self, target: Target): ...
    def add_node(self, branch: Branch): ...

# Names in __all__ with no definition:
#   get_logic_names
